## 7.3 Replace Primitive with Object
- 처음에는 전화번화를 문자열로 표현했는데 나중에 포매팅이나 지역 코드 추출 같은 특별한 동작이 필요해질 수 있다. 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의한다.
- 필드를 자가 캡슐화하면 필드 이름을 바꿔도 클라이언트 코드는 유지할 수 있다.

## 7.4 Replace Temp with Query
- 이번 리팩터링은 클래스 안에서 적용할 때 효과가 가장 크다. 클래스는 추출할 메서드들에 공유 컨텍스트를 제공하기 때문이다.

## 7.5 Extract Class
- 메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다. 특히 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호다.
- 특정 데이터나 메서드를 제거해도 다른 필드나 메서드들이 논리적으로 문제가 없다면 분리할 수 있다는 뜻이다.

## 7.6 Inline Class <-> Extract Class
- 더 이상 제 역할을 못해서 그대로 두면 안되는 클래스는 인라인해버린다. 역할을 옮기는 리팩터링을 하고나니 특정 클래스에 남은 역할이 거의 없을 때 이런 현상이 자주 생긴다.
- 클래스를 인라인해서 하나로 합친 다음 새로운 클래스를 추출하는게 쉬울수도 있다.(코드를 재구성할 때 흔히 사용하는 방식)

## 7.7 Hide Delegate
- 모듈화 설계를 제대로 하는 핵심은 캡슐화
- 캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야 할 내용을 줄여준다. 캡슐화가 잘 되어 있다면 무언가를 변경해야 할 때 함께 고려해야 할 모듈 수가 적어져서 코드를 변경하기가 훨씬 쉬워진다.
- 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 의존성을 없앨 수 있다. 그러면 위임 객체가 수정되더라도 클라이언트는 아무런 영향을 받지 않는다.

## Remove Middle Man <-> Hide Delegate
- 서버 클래스가 중개자 역하로 전락하여 차라리 클라이언트가 직접 위임 객체의 메서드를 호출하는게 나을 때 이 리팩터링 기법을 사용한다. (디미터의 법칙)
- 서버 클래스의 위임 메서드가 많아질 경우

## Substitude Algorithm
- 말그대로 알고리즘 교체, 훨씬 간결한 알고리즘이 생각났을 때 이 리팩터링 기법을 사용한다.
