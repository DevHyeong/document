# 1장 오브젝트와 의존관계

## 관심사의 분리
- 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다.
- 가장 좋은 대책은 변화의 폭을 최소한으로 줄여주는 것이다.
- 어떻게 변경이 일어날 때 필요한 작업을 최소화할 수 있고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있었을까?
- 그것은 분리와 확장을 고려한 설계가 있었기 때문

## 2가지 패턴을 통한 관심사 분리
- 관심이 다른 기능을 분리하고 필요에 따라 다양한 변신이 가능하도록 확장성을 높힘
### 템플릿 메소드 패턴
- 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다.
- 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.
- 슈퍼클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다.
- 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택저으로 오버라이드할 수 있도록 만들어둔 메소드를 훅(Hook) 메소드라 한다.
- 서브클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다.

### 팩토리 메소드 패턴
- 슈퍼클래스 코드에서는 서브클래스에서 구현한 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다.
- 이 메소드는 주로 인터페이스 타입의 오브젝트를 리턴하므로 서브클래스에서 정확히 어떤 구현 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서 알지 못한다.
- 서브클래스에서는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있다.
- 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.

## 상속을 통한 문제
- 자바는 클래스의 다중상속을 허용하지 않는다. 단지 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.
- 상속을 통한 상하위 클래스의 관계가 생각보다 밀접하다.(결합도 증가)

## 해결법: 인터페이스를 통한 추상화
- 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업
- 인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버린다.
- 생섯자 파라미터 또는 메소드 파라미터를 통한 의존관게 설정으로 유연한 관계를 맺을 수 있다.(런타임 의존관계)

## 원칙과 패턴
### 개방 폐쇄 원칙(OCP, Open-Closed Principle)
- 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야 한다.
### 높은 응집도
- 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다
### 낮은 결합도
- 결합도: 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도
- 낮은 결합도: 하나의 변경이 발생할 때 마치 파문이 이는 것처럼 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태
### 전략 패턴
- 자신의 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.
- 여기서 말하는 알고리즘이란 독립적인 책임으로 분리가 가능한 기능을 뜻한다. 이를 대체 가능한 전략이라고 보기 때문에 패턴의 이름이 전략 패턴이다.

### 스프링이란 객체지향적 설계 원칙과 디자인 패턴에 나타난 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임워크다.

## 제어의 역전(IoC, Inversion of Control)
### 오브젝트 팩토리
- 팩토리(factory) : 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할을 하는 클래스
- 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡음
- 컴포넌트의 의존관계에 대한 설계도와 같은 역할
### 제어권의 이전을 통한 제어관계 역전
- 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.
- 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.
- 라이브러리는 애플리케이션 흐름을 개발자가 직접 제어한다. 하지만 프레임워크는 개발자가 아닌 프레임워크가 직접 제어한다.
- 애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다.
- 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.

## 스프링의 IoC
### 애플리케이션 컨텍스트와 설정정보
- 빈(Bean): 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
- 빈 팩토리(bean factory): 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
- 보통 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트를 주로 사용한다.(일종의 빈 팩토리라고 생각하면 된다)
- 애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다.

### 애플리케이션 컨텍스트의 동작방식
- 애플리케이션 컨텍스트는 ApplicationContext 인터페이스를 구현하는데 ApplicationContext는 빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 애플리케이션 컨텍스트는 일종의 빈 팩토리인 셈이다.
- 애플리케이션 컨텍스트는 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다.
- 애플리케이션 컨텍스트는 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고, 그런 생성정보와 연관관계 정보를 별도의 설정정보를 통해 얻는다.
- 애플리케이션 컨텍스트는 @Configuration으로 정의된 클래스를 설정정보로 등록해두고 @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다. 클라이언트가 애플리케이션 컨텍스트의 getBean() 메소드를 호출하면 자신의 빈 목록에서 요청한 이름이 있느지 찾고, 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 돌려준다.

### 스프링 IoC의 용어 정리
#### 빈
#### 빈 팩토리
#### 애플리케이션 컨텍스트
#### 설정정보/설정 메타정보
- 스프링 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다.
- IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.
#### 컨테이너 또는 IoC 컨테이너
- 애플리케이션 컨텍스트는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 가리키기도 하는데, 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용된다. 이를 통틀어서 스프링 컨테이너라고 부를 수 있다.

## 싱글톤 레지스트리와 오브젝트 스코프
- 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 하다.
- 스프링은 기본적으로 별다른 설정이 없으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다. (디자인패턴 중 하나인 싱글톤 패턴과는 구현 방법이 다름)
### 서버 애플리케이션과 싱글톤
- 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다.
- 서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.
### 싱글톤 패턴
#### 구현방식
- 생성자를 private으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
- 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에는 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다.
- 한번 오브젝트가 만들어지고 난 후에는 getInstance() 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.
#### 한계
- private 생성자를 갖고 있기 때문에 상속할 수 없다.
- 테스트하기 힘들다.
- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다(동시성 이슈)
### 싱글톤 레지스트리
- 싱글톤 레지스트리: 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
- 스프링은 IoC 컨에티너일 뿐만 아니라 고전적인 싱글톤 패턴을 대신해서 싱글톤을 만들고 관리해주는 싱글톤 레지스트리라는 점을 기억하자.
### 싱글톤과 오브젝트의 상태
- 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리에 주의를 기울여야 한다.
- 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다.
- 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다.
- 읽기 전용의 속성을 가진 정보는 싱글톤에서 인스턴스 변수로 사용해도 좋다.

### 스프링 빈의 스코프
- 스프링 빈의 기본 스코프는 싱글톤이다. (스프링 컨테이너가 존재하는 동안 계속 유지된다.)
- 프로토타입 스코프: 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만든다.
- 요청 스코프, 세션 스코프
- 싱글톤 외의 빈의 스코프는 10장에서 자세히 알아보자.
