# 6장 AOP
- AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술의 하나다.
- 스프링에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이다.
- 서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔보자.
- 그리고 그 과정에서 스프링이 AOP를 도입해야 했던 이유도 알아보자.

## 6.1 트랜잭션 코드의 분리
- 아래는 UserService 클래스의 코드 일부이다.
```java
public void upgradeLevels() {
		TransactionStatus status = 
		  this.transactionManager.getTransaction(new DefaultTransactionDefinition());
		try {
			List<User> users = userDao.getAll();
			for (User user : users) {
				if (canUpgradeLevel(user)) {
					upgradeLevel(user);
				}
			}
			this.transactionManager.commit(status);
		} catch (RuntimeException e) {
			this.transactionManager.rollback(status);
			throw e;
		}
}
```

- 트랜잭션 경계설정 코드와 비즈니스 로직 코드로 두 가지 종류의 코드가 구분되어 있음을 알 수 있다.
- 이 두 가지 코드는 성격이 다를 뿐 아니라 서로 주고받는 것도 없는 완벽하게 독립적인 코드다.

### DI를 이용한 클래스의 분리
- DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것이다. 그 덕분에 구현 클래스는 얼마든지 외부에서 변경할 수 있다.
- UserService를 인터페이스로 변경
- UserService 인터페이스의 구현 클래스 2개 정의
  - UserServiceImpl : 비즈니스 로직을 담당하는 클래스
  - UserServiceTx : 트랜잭션 경계설정을 담당하는 클래스
- UserServiceTx는 스스로는 비즈니스 로직을 담고 있지 않기 때문에 비즈니스 로직을 담고 있는 UserServiceImpl에 실제적인 로직 처리 작업은 위임하는 것이다.

### 트랜잭션 경계설정 코드 분리의 장점
- 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.
- 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭셕 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.
- 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

## 6.2 고립된 단위 테스트
- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다. (디버깅이 쉬워짐)
- 하지만 작은 단위로 테스트하고 싶어도 그럴수 없는 경우가 많다.
- 테스트 대상이 다른 오브젝트와 환경에 의존한다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

### 테스트 대상 오브젝트 고립시키기
- 테스트의 대상이 환경이나 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다. (테스트를 위한 대역 사용, 테스트 스텁 또는 목 오브젝트)

#### 테스트를 위한 UserServiceImpl 고립
- UserDao: 정상적인 수행 + 부가적인 검증 기능까지 가진 목 오브젝트 생성, 그 이유는 고립된 환경에서 동작하는 upgradeLevels()의 테스트 결과를 검증할 방법이 필요하기 때문
- getAll(): 레벨 업그레이드 후보가 될 사용자의 목록을 받아온다. DB에 읽어온 것처럼 미리 준비된 사용자 목록을 제공해줘야 한다. (스텁)
- update(): upgradeLevels()의 핵심 로직인 전체 사용자 중에서 업그레이드 대상자는 레벨을 변경해준다에서 변경에 해당하는 부분을 검증할 수 있는 중요한 기능이다. (목 오브젝트)
- 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없을 뿐만 아니라 테스트 수행 성능도 크게 향상된다.
- 고립된 테스트를 만들려면 목 오브젝트 작성과 같은 약간의 수고가 더 필요할지 모르겠지만 그 보상은 충분히 기대할 만하다.

### 단위 테스트와 통합 테스트
- 단위 테스트의 단위는 정하기 나름이다. 사용자 관리 기능 전체를 하나의 단위로 볼 수도 있고 하나의 클래스나 하나의 메서드를 단위로 볼 수도 있다. 
- 토비의 스프링에서 정의한 단위 테스트는 의존 오브젝트나 외부 리소스를 사용하지 않고 고립시켜서 하는 테스트다.
- 통합 테스트는 다른 오브젝트나 외부 리소스가 참여하는 테스트
### 단위 테스트와 통합 테스트 중에서 어떤 방법을 쓸지에 대한 가이드 라인
- 항상 단위 테스트를 먼저 고려한다
- 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하여 테스트를 만든다
- 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다
- 단위 테스트로 만들기가 어려운 코드도 있다. 대포적인 게 DAO다. DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고 DB에 직접 확인을 하는 등의 부가적인 작업이 필요하다.
- 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다. 다만 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.
- 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다. 이때도 통합 테스트에 참여하는 코드 중에서 가능한 한 많은 부분을 미리 단위 테스트로 검증해두는게 유리하다.
- 스프링의 설정 자체도 테스트 대상이고 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야 할 경우도 종종 있다. 이럴 땐 스프링 테스트 컨텍스트 프레임워크를 이용해 통합 테스트를 작성한다.

코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다. 테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.
스프링이 지지하고 권장하는 깔끔하고 유연한 코드를 만들다보면 테스트도 그만큼 만들기 쉬워지고 테스트는 다시 코드의 품질을 높여주고 리팩토링과 개선에 대한 용기를 주기도 할 것이다.
  
## 6.3 다이내믹 프록시와 팩토리 빈
- 트랜잭션 경계설정 코드를 비즈니스 로직 코드에서 분리해낼 때 적용했던 기법을 다시 검토해보자
- 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야 한다.
- 그러기 위해서는 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 한다.
- 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 프록시라고 부른다. 그리고 프록시를 통해 최종족으로 요청을 위임받아 처리하는 실제 오브젝트를 타킷 또는 실체라고 부른다.
- 프록시는 사용 목적에 따라 두가지로 구분할 수 있다. 첫째는 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서다. 두 번째는 타깃에 부가적인 기능을 부여해주기 위해서다.

### 데코레이터 패턴
- 데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.
- 이를 위해 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있다.
- 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃으로 위임하는지 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.

### 프록시 패턴
- 일반적으로 사용하는 프록시라는 용어와 디자인 패턴에서 말하는 프록시 패턴은 구분할 필요가 있다. 전자는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭한다면 후자는 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.
- 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
- Collections의 unmodifiableCollection()을 통해 만들어지는 오브젝트가 전형적인 접근권한 제어용 프록시
- 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다.

### 다이내믹 프록시
- 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.
```java
public interface InvocationHandler {
    Object invoke(Object proxy, Method method, Object[] args)
}

```

```java 
Hello proxiedHello = (Hello) Proxy.newProxyInstance(
    getClass().getClassLoader(),
    new Class[] (Hello.class),
    new UppercaseHandler(new HelloTarget())
    );

```
- 다이내믹 프록시로부터 요청을 전달받으려면 InvocationHandler를 구현해야 한다. 다이내믹 프록시가 클라이언트로부터 받는 모든 요청은 invoke() 메소드로 전달된다. 다이내믹 프록시를 통해 요청이 전달되면 리플렉션 API를 이용해 타깃 오브젝트의 메소드를 호출한다.

### 다이내믹 프록시를 위한 팩토리 빈
- 스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러 가지 방법을 제공한다. 대표적으로 팩토리 빈을 이용하여 빈을 생성하는 것이다.
- 팩토리 빈이란 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈을 말한다.
- 팩토리 빈을 만드는 방법에는 여러 가지가 있는데 가장 간단한 방법은 FactoryBean 인터페이스를 구현하는 것이다.
- FactoryBean 인터페이스를 구현한 클래스를 빈으로 등록하면 팩토리 빈으로 동작한다.
- 참고로 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 오브젝트를 만들어준다. 리플렉션은 private으로 선언된 접근 규약을 위반할 수 있는 강력한 기능이 있기 때문이다.
- Proxy의 newProxyInstance() 메소드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다. 대신 팩토리 빈을 사용하면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어줄 수 있다.
#### 한계점
- 새로운 부가기능을 추가할 때마다 프록시와 프록시 팩토리 빈을 추가해줘야 한다.

## 6.4 스프링의 프록시 팩토리 빈
### ProxyFactoryBean
- 스프링의 ProxyFactoryBean은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다. ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.
- 여러 프록시가 공유해서 사용할 수 있다.
- MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받는다. 그 차이 덕분에 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다.
```java
class UppercaseAdvice implements MethodInterceptor {
    public Object invoke(MethodInvocation invocation) throws Throwable {
        String ret = (String)invocation.proceed();
	return ret.toUpperCase();
    }
}
```
- 다이내믹 프록시와 달리 ProxyFactoryBean 방식은 두 가지 확장 기능인 부가기능(Advice)와 메소드 선정 알고리즘(Pointcut)을 활용하는 유연한 구조를 제공한다.
- 어드바이스와 포인트컷은 모두 프록시에 DI로 주입돼서 사용된다.
- 두 가지 모두 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 스프링의 싱글톤 빈으로 등록이 가능하다.

#### proxyFactoryBean 동작원리
1. 프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할 메소드인지 확인해달라고 요청한다
2. 프록시는 포인트컷으로부터 부가기능을 적용할 대상 메소드인지 확인받으면 MethodInteceptor 타입의 어드바이스를 호출한다.


```java
@Test
public void pointcutAdvisor(){
    ProxyFactoryBean pfBean = new ProxyFactoryBean();
    pfBean.setTarget(new HelloTarget());

    NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();
    pointcut.setMappedName("sayH*");

    pfBean.addAdvisor(new DefaultPointcutAdvisor(pointcut, new UppercaseAdvice()));

    Hello proxiedHello = (Hello) pfBean.getObject();

    assertThat(proxiedHello.sayHello("Toby"), is("HELLO TOBY"));
    assertThat(proxiedHello.sayHi("Toby"), is("HI TOBY"));
    assertThat(proxiedHello.sayThankYou("Toby"), is("Thank You Toby"));
}

```


- MethodInterceptor는 타깃에 직접 의존하지 않도록 일종의 템플릿 구조로 설계되어 있다. (템플릭/콜백 구조)
- 포인트컷을 함께 등록할 때는 어드바이스와 포인트컷을 Advisor 타입으로 묶어서 addAdvisor() 메소드를 호출해야한다. 왜냐하면 ProxyFactoryBean에는 여러 개의 어드바이스와 포인트컷이 추가될 수 있기 때문이다. 포인트컷과 어드바이스를 따로 등록하면 어떤 어드바이스에 대해 어떤 포인트컷을 적용할지 애매해지기 때문이다.
- 토비의 스프링에서는 어드바이스, 포인트컷, 어드바이스, ProxyFactoryBean을 스프링 빈 설정하여 다이내믹 프록시 코드를 개선한다.
- 이렇게 설정된 스프링 빈은 다양한 서비스 클래스 등 재사용이 가능하다. (ProxyFactoryBean은 타깃의 정보를 하나만 담을수있기에 여러개의 ProxyFactoryBean을 등록하여 사용해야 한다.)
  
## 6.5 스프링 AOP
- 지금까지 해왔던 작업의 목표는 비즈니스 로직에 반복적으로 등장해야만 했던 트랜잭션 코드를 깔끔하고 효과적으로 분리해내는 것이다.

### 빈 후처리기를 이용한 자동 프록시 생성기 DefaultAdvisorAutoProxyCreator
- 스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 확장 포인트를 제공해준다.
- 그 중에서 관심을 가질 만한 확장 포인트는 바로 BeanPostProcessor 인터페이스를 구현해서 만드는 빈 후처리기다.
- 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다. 이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고 프록시를 빈으로 대신 등록할 수도 있다. 이것이 자동 프록시 생성 빈 후처리기다.

### 빈 후처리기를 이용한 자동 프록시 생성 방법
1. DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
2. 프록시 적용 대상이면 그때는 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고 만들어진 프록시에 어드바이저를 연결해준다.
3. 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해 준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에 돌려준다.
4. 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.

### 확장된 포인트컷(Pointcut 인터페이스)
```java
public interface Pointcut {
    ClassFilter getClassFilter(); // 프록시를 적용할 클래스인지 확인해준다.
    MethodMatcher getMethodMatcher(); // 어드바이스를 적용할 메서드인지 확인해준다.
}
```
- 포인트컷이 클래스 필터까지 동작해서 클래스를 걸러버리면 아무리 프록시를 적용했다고 해도 부가기능은 전혀 제공되지 않는다는 점에 주의해야 한다.

### DefaultAdvisorAutoProxyCreator 적용
- ProxyFactoryBean 제거와 서비스 빈의 원상복구

### 자동 프록시 생성기를 사용하는 테스트
- 자동 프록시 생성기는 스프링 컨테이너에 종속적인 기법을 사용했기 때문에 예외상황을 위한 테스트 대상도 빈으로 등록해줄 필요가 있다. 이제는 타깃을 코드에서 바꿔치기할 방법도 없을뿐더러 자동 프록시 생성기의 적용이 되는지도 빈을 통해 확인할 필요가 있기 때문이다.
- 테스트용 UserService 빈등록 (특정 테스트 클래스에서만 사용되는 클래스는 스태틱 멤버 클래스로 정의하는 것이 편리하다)
- 해당 테스트는 최소한 두 가지는 확인해야 한다. 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는가와 프록시 자동생성기가 어드바이저 빈에 연결해둔 포인트컷의 클래스 필터를 이용해서 정확히 원하는 빈에만 프록시를 생성했는지 확인이 필요하다.

### 포인트컷 표현식을 이용한 포인트컷
- 포인트컷 표현식을 지원하는 포인트컷을 적용하려면 AspectJExpressionPointcut 클래스를 사용하면 된다. 사실 스프링이 사용하는 포인트컷 표현식은 AspectJ라는 유명한 프레임워크에서 제공하는 것을 가져와 일부 문법을 확장해서 사용하는 것이다. 그래서 이를 AspectJ 포인트컷 표현식이라고도 한다.
- AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성한다. 포인트컷 지시자 중에서 가장 대표적으로 사용되는 것은 execution()이다.
- 포인트컷 표현식은 AspectJExpressionPointcut 빈을 등록하고 expression 프로퍼티에 넣어주면 된다.
```xml
<bean id="transactionPointcut" class="org.springframework.aop.aspectj.AspectJExpressionPointcut">
    <property name="expression" value="execution(* *..*ServiceImpl.upgrade*(..))*" />
</bean>
```
- 하지만 문자열로 된 표현식이므로 런타임 시점까지 문법의 검증이나 기능 확인이 되지 않는다는 단점이 있다.
- 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입 패턴이다.

### AOP란 무엇인가? (정리)
#### 트랜잭션 서비스 추상화
- 인터페이스와 DI를 통해 특정 트랜잭션 기술에 종속적인 코드가 아닌 런타임시에 유연하게 변경할 수 있게 되었다.

#### 프록시와 데코레이터 패턴
- 트랜잭션이라는 부가적인 기능을 프록시와 데코레이터 패턴을 통해 비즈니스 로직으로부터 분리
- 단점: 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 프록시 클래스를 만들어야 했다

#### 다이내믹 프록시와 프록시 팩토리 빈
- 프록시 클래스 없이 프록시 오브젝트를 런타임시에 만들어주는 JDK 다이내믹 프록시 기술을 적용
- 단점: 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로는 중복이 일어나는 문제가 발생 -> 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성 방법에 DI를 도입
- 내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와 부가기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고 여러 프록시에서 공유해서 사용할 수 있게 되었다.
- 단점: 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야 한다.

#### 자동 프록시 생성 방법과 포인트컷
- 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입

### AOP 적용기술
#### 프록시를 이용한 AOP
- 스프링 AOP의 부가기능을 담은 어드바이스가 적용되는 대상은 오브젝트의 메소드다. 프록시 방식을 사용했기 때문에 메소드 호출 과정에 참여해서 부가기능을 제공해주게 되어 있다.
- 어드바이스가 구현하는 MethodInterceptor 인터페이스는 다이내믹 프록시의 InvocationHandler와 마찬가지로 프록시로부터 메소드 요청정보를 전달받아서 타깃 오브젝트의 메소드를 호출한다.
- 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 맡고 있는게 바로 프록시다.

#### 바이트코드 생성과 조작을 통한 AOP
- AOP 프레임워크로 꼽히는 AspectJ는 프록시를 사용하지 않는 대표적인 AOP 기술이다.
- AspectJ는 프록시처럼 간접적인 방법이 아니라 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용한다.
- 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다. 물론 소스코드를 수정하지는 않으므로 개발자는 비즈니스 로직에 충실한 코드를 만들 수 있다.
- 프록시가 아닌 바이트코드 조작과 같은 복잡한 방법을 사용하는 이유
- 1. 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있기 때문
  2. 프록시를 AOP의 핵심 매커니즘으로 사용하면 부가기능을 부여할 대상은 클라이언트가 호출할 때 사용하는 메서드로 제한된다. 하지만 바이트코드를 직접 조작해서 AOP를 적용하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가기능을 부여해줄 수 있다.

### AOP 용어
- 타깃: 부가기능을 부여할 대상이다.
- 어드바이스: 타깃에게 제공할 부가기능을 담은 모듈
- 조인 포인트: 어드바이스가 적용될 수 있는 위치를 말한다. 스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계뿐이다.
- 포인트컷: 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈을 말한다. 스프링 AOP의 조인 포인트는 메소드의 실행이므로 스프링의 포인트컷은 메소드를 선정하는 기능을 갖고 있다.
- 프록시: 프록시는 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트이다.
- 어드바이저: 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트다. 어드바이저는 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈이다.
- 에스펙트: 한개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다.

### AOP 네임스페이스
- 스프링의 프록시 방식 AOP를 적용하려면 최소한 네 가지 빈을 등록해야 한다.
- 자등 프록시 생성기: 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다. 애플리케이션 컨텍스트가 빈 오브젝트를 생성하는 과정에 빈 후처기로 참여하낟. 빈으로 등록된 어드바이저를 이용해서 프록시를 자동으로 생성하는 기능을 담당한다.
- 어드바이스: 부가기능을 구현한 클래스를 빈으로 등록한다.
- 포인트컷: 스프링의 AspectJExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에 포인트컷 표현식을 넣어주면 된다.
- 어드바이저: 스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용한다. 자동 프록시 생성기에 의해 자동 검색되어 사용된다.

## 트랜잭션 속성
### 트랜잭션
#### 트랜잭션 전파
- 트랜잭션 전파란 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식을 말한다.
- PROPAGATION_REQUIRED: 가장 많이 사용되는 트랜잭션 전파 속성이다. 진행 중인 트랜잭션이 없으면 새로 시작하고 이미 시작된 트랜잭션이 있으면 이에 참여한다.
- PROPAGATION_REQUIRES_NEW: 항상 새로운 트랜잭션을 시작한다.
- PROPAGATION_NOT_SUPPORTED: 이 속성을 사용하면 트랜잭션 없이 동작하도록 만들 수 있다.
- 진행중인 트랜잭션에 참여하는 경우는 트랜잭션 경계의 끝에서 트랜잭션을 커밋시키지도 않는다. 최초로 트랜잭션을 시작한 경계까지 정상적으로 진행돼야 비로소 커밋될 수 있다.

#### 격리수준
- 모든 DB 트랜잭션은 격리수준을 갖고 있어야 한다. 격리수준은 기본적으로 DB에 설정되어 있지만 JDBC 드라이버나 DataSource 등에서 재설정할 수 있고 필요하다면 트랜잭션 단위로 격리수준을 조정할 수 있다.
- DefaultTransactionDefinition에 설정된 격리수준은 ISOLATION_DEFAULT다. 이는 DataSource에 설정되어 있는 디폴트 격리수준을 그대로 따른다는 뜻이다.

#### 제한시간
- 트랜잭션을 수행하는 제한시간을 설정할 수 있다. DefaultTransactionDefiniton의 기본 설정은 제한시간이 없는 것이다.

#### 읽기전용
- 읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다. 또한 데이터 액세스 기술에 따라서 성능이 향상될 수도 있다.

#### TransactionInterceptor
- 메소드별로 다른 트랜잭션 정의를 적용하려면 어드바이스 기능을 확장해야 한다. TransactionInterceptor는 PlatformTransactionManager와 Properties 타입의 두 가지 프로퍼티를 갖고 있다.
- Properties 타입인 두번쨰 프로퍼티는 트랜잭션 속성을 정의한 프로퍼티다. 트랜잭션 속성은 TransactionDefinition의 네 가지 기본 항목에 rollbackOn()이라는 메소드를 하나 더 갖고 있는 TransactionAttribute 인터페이스로 정의된다.
- 스프링이 제공하는 TransactionInterceptor에는 기본적으로 두 가지 종류의 예외처리 방식이 있다. 런타임 예외가 발생하면 트랜잭션은 롤백된다. 반면에 타겟 메소드가 런타임 예외가 아닌 체크 예외를 던지는 경우에는 트랜잭션을 커밋해버린다. 
- Properties 타입의 transactionAttributes 프로퍼티는 메소드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션이다.

### 포인트컷과 트랜잭션 속성의 적용 전략
#### 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.
- 일반적으로 트랜잭션을 적용할 타깃 클래스의 메소드는 모두 트랜잭션 적용 후보가 되는 것이 바람직하다.
- 쓰기 작업이 없는 단순한 조회 작업만 하는 메소드에도 모두 트랜잭션을 적용하는 게 좋다. 조회의 경우에는 읽기 전용으로 트랜잭션 속성을 설정해두면 그만큼 성능의 향상을 가져올 수 있다.
- 복잡한 조회의 경우는 제한시간을 지정해줄 수도 있고 격리수준에 따라 조회도 반드시 트랜잭션 안에서 진행해야 할 필요가 발생하기도 한다.
- 따라서 트랜잭션용 포인트컷 표현식에는 메소드나 파라미터, 예외에 대한 패턴을 정의하지 않는 게 바람직하다.

#### 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.
- 실제로 하나의 애플리케이션에서 사용할 트랜잭션 속성의 종류는 그다지 다양하지 않다. 너무 다양하게 트랜잭션 속성을 부여하면 관리만 힘들어질 뿐이다. 따라서 기준이 되는 몇 가지 트랜잭션 속성을 정의하고 그에 따라 적절한 메소드 명명 규칙을 만들어두면 하나의 어드바이스만으로 애플리케이션의 모든 서비스 빈에 트랜잭션 속성을 지정할 수 있다.

#### 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.
- 이건 전략이라기보다는 주의사항이다.
- 프록시 방식의 AOP에서는 프록시를 통한 부가기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하다. 여기서 클라이언트는 인터페이스를 통해 타깃 오브젝트를 사용하는 다른 모든 오브젝트를 말한다.
- 반대로 타깃 오브젝트가 자기 자신의 메소드를 호출할 때는 프록시를 통한 부가기능의 적용이 일어나지 않는다.
- 같은 타깃 오브젝트 안에서 메소드 호출이 일어나는 경우에는 프록시 AOP를 통해 부여해준 부가기능이 적용되지 않는다는 점을 주의해야 한다. 따라서 같은 오브젝트 안에서의 호출은 새로운 트랜잭션 속성을 부여하지 못한다는 사실을 의식하고 개발할 필요가 있다.
- 해결법: AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술을 적용하는 것이다. 하지만 그만큼 다른 불편도 뒤따르기 때문에 꼭 필요한 경우에만 사용해야 한다.

### 트랜잭션 속성 적용
#### 트랜잭션 경계설정의 일원화
- 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직하다. 비즈니스 로직을 담고 있는 서비스 계층 오브젝트의 메소드가 트랜잭션 경계를 부여하기에 가장 적절한 대상이다.
- 가능하면 다른 모듈의 DAO에 접근할 때는 서비스 계층을 거치도록 하는게 바람직하다.
- 물론 순수한 조회나 간단한 수정이라면 서비스 계층 오브젝트에서 DAO를 직접 사용해도 상관없다. 하지만 등록이나 수정, 삭제가 포함된 작업이라면 다른 모듈의 DAO를 직접 이용할 때 신중을 기해야 한다.

## 애노테이션 트랜잭션 속성과 포인트컷
### 트랜잭션 애노테이션
- 스프링은 @Transactional이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식한다. 이때 사용되는 포인트컷은 TransactionAttributeSourcePointcut이다. 
- @Transactional은 기본적으로 트랜잭션 속성을 정의하는 것이지만 동시에 포인트컷의 자동등록에도 사용된다.
- 스프링은 @Transactional의 엘리멘트에서 트랜잭션 속성을 가져오는AnnotationTransactionAttributeSource를 사용한다.
- 스프링은 메소드의 속성을 확인할 때 타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입(클래스, 인터페이스)의 순서에 따라서 @Transactional이 적용됐는지 차례로 확인하고 가장 먼저 발견되는 속성정보를 사용하게 하는 방법이다.
- @Transactional을 사용하면 대체 정책을 잘 활용해서 애노테이션 자체는 최소한으로 사용하면서도 세밀한 제어가 가능하다.
- @Transactional은 먼저 타입 레벨에 정의되고 공통 속성을 따르지 않는 메소드에 대해서만 메소드 레벨에 다시 @Transactional을 부여해주는 식으로 사용해야 한다.
- 인터페이스를 사용하는 프록시 방식의 AOP가 아닌 방식으로 트랜잭션을 적용하면 인터페이스에 정의한 @Transactional은 무시되기 떄문에 안전하게 타깃 클래스에 @Transactional을 두는 방법을 권장한다.
- 인터페이스에 @Transactional을 두면 구현 클래스가 바뀌더라도 트랜잭션 속성을 유지할 수 있다는 장점이 잇다.
- @Transactional을 사용하기 위해서는 아래의 설정이 필요하다.
```xml
<tx:annotation-driven/>
```
- 

