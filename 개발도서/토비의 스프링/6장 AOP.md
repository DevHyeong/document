# 6장 AOP
- AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술의 하나다.
- 스프링에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이다.
- 서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔보자.
- 그리고 그 과정에서 스프링이 AOP를 도입해야 했던 이유도 알아보자.

## 6.1 트랜잭션 코드의 분리
- 아래는 UserService 클래스의 코드 일부이다.
```java
public void upgradeLevels() {
		TransactionStatus status = 
		  this.transactionManager.getTransaction(new DefaultTransactionDefinition());
		try {
			List<User> users = userDao.getAll();
			for (User user : users) {
				if (canUpgradeLevel(user)) {
					upgradeLevel(user);
				}
			}
			this.transactionManager.commit(status);
		} catch (RuntimeException e) {
			this.transactionManager.rollback(status);
			throw e;
		}
}
```

- 트랜잭션 경계설정 코드와 비즈니스 로직 코드로 두 가지 종류의 코드가 구분되어 있음을 알 수 있다.
- 이 두 가지 코드는 성격이 다를 뿐 아니라 서로 주고받는 것도 없는 완벽하게 독립적인 코드다.

### DI를 이용한 클래스의 분리
- DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것이다. 그 덕분에 구현 클래스는 얼마든지 외부에서 변경할 수 있다.
- UserService를 인터페이스로 변경
- UserService 인터페이스의 구현 클래스 2개 정의
  - UserServiceImpl : 비즈니스 로직을 담당하는 클래스
  - UserServiceTx : 트랜잭션 경계설정을 담당하는 클래스
- UserServiceTx는 스스로는 비즈니스 로직을 담고 있지 않기 때문에 비즈니스 로직을 담고 있는 UserServiceImpl에 실제적인 로직 처리 작업은 위임하는 것이다.

### 트랜잭션 경계설정 코드 분리의 장점
- 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.
- 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭셕 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.
- 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

## 6.2 고립된 단위 테스트
- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다. (디버깅이 쉬워짐)
- 하지만 작은 단위로 테스트하고 싶어도 그럴수 없는 경우가 많다.
- 테스트 대상이 다른 오브젝트와 환경에 의존한다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

### 테스트 대상 오브젝트 고립시키기
- 테스트의 대상이 환경이나 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다. (테스트를 위한 대역 사용, 테스트 스텁 또는 목 오브젝트)

#### 테스트를 위한 UserServiceImpl 고립
- UserDao: 정상적인 수행 + 부가적인 검증 기능까지 가진 목 오브젝트 생성, 그 이유는 고립된 환경에서 동작하는 upgradeLevels()의 테스트 결과를 검증할 방법이 필요하기 때문
- getAll(): 레벨 업그레이드 후보가 될 사용자의 목록을 받아온다. DB에 읽어온 것처럼 미리 준비된 사용자 목록을 제공해줘야 한다. (스텁)
- update(): upgradeLevels()의 핵심 로직인 전체 사용자 중에서 업그레이드 대상자는 레벨을 변경해준다에서 변경에 해당하는 부분을 검증할 수 있는 중요한 기능이다. (목 오브젝트)
- 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없을 뿐만 아니라 테스트 수행 성능도 크게 향상된다.
- 고립된 테스트를 만들려면 목 오브젝트 작성과 같은 약간의 수고가 더 필요할지 모르겠지만 그 보상은 충분히 기대할 만하다.

### 단위 테스트와 통합 테스트
- 단위 테스트의 단위는 정하기 나름이다. 사용자 관리 기능 전체를 하나의 단위로 볼 수도 있고 하나의 클래스나 하나의 메서드를 단위로 볼 수도 있다. 
- 토비의 스프링에서 정의한 단위 테스트는 의존 오브젝트나 외부 리소스를 사용하지 않고 고립시켜서 하는 테스트다.
- 통합 테스트는 다른 오브젝트나 외부 리소스가 참여하는 테스트
### 단위 테스트와 통합 테스트 중에서 어떤 방법을 쓸지에 대한 가이드 라인
- 항상 단위 테스트를 먼저 고려한다
- 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하여 테스트를 만든다
- 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다
- 단위 테스트로 만들기가 어려운 코드도 있다. 대포적인 게 DAO다. DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고 DB에 직접 확인을 하는 등의 부가적인 작업이 필요하다.
- 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다. 다만 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.
- 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다. 이때도 통합 테스트에 참여하는 코드 중에서 가능한 한 많은 부분을 미리 단위 테스트로 검증해두는게 유리하다.
- 스프링의 설정 자체도 테스트 대상이고 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야 할 경우도 종종 있다. 이럴 땐 스프링 테스트 컨텍스트 프레임워크를 이용해 통합 테스트를 작성한다.

코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다. 테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.
스프링이 지지하고 권장하는 깔끔하고 유연한 코드를 만들다보면 테스트도 그만큼 만들기 쉬워지고 테스트는 다시 코드의 품질을 높여주고 리팩토링과 개선에 대한 용기를 주기도 할 것이다.
  


