# 6장 AOP
- AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술의 하나다.
- 스프링에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이다.
- 서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔보자.
- 그리고 그 과정에서 스프링이 AOP를 도입해야 했던 이유도 알아보자.

## 6.1 트랜잭션 코드의 분리
- 아래는 UserService 클래스의 코드 일부이다.
```java
public void upgradeLevels() {
		TransactionStatus status = 
		  this.transactionManager.getTransaction(new DefaultTransactionDefinition());
		try {
			List<User> users = userDao.getAll();
			for (User user : users) {
				if (canUpgradeLevel(user)) {
					upgradeLevel(user);
				}
			}
			this.transactionManager.commit(status);
		} catch (RuntimeException e) {
			this.transactionManager.rollback(status);
			throw e;
		}
}
```

- 트랜잭션 경계설정 코드와 비즈니스 로직 코드로 두 가지 종류의 코드가 구분되어 있음을 알 수 있다.
- 이 두 가지 코드는 성격이 다를 뿐 아니라 서로 주고받는 것도 없는 완벽하게 독립적인 코드다.

### DI를 이용한 클래스의 분리
- DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것이다. 그 덕분에 구현 클래스는 얼마든지 외부에서 변경할 수 있다.
- UserService를 인터페이스로 변경
- UserService 인터페이스의 구현 클래스 2개 정의
  - UserServiceImpl : 비즈니스 로직을 담당하는 클래스
  - UserServiceTx : 트랜잭션 경계설정을 담당하는 클래스
- UserServiceTx는 스스로는 비즈니스 로직을 담고 있지 않기 때문에 비즈니스 로직을 담고 있는 UserServiceImpl에 실제적인 로직 처리 작업은 위임하는 것이다.

### 트랜잭션 경계설정 코드 분리의 장점
- 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.
- 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭셕 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.
- 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

## 6.2 고립된 단위 테스트
- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다. (디버깅이 쉬워짐)
- 하지만 작은 단위로 테스트하고 싶어도 그럴수 없는 경우가 많다.
- 테스트 대상이 다른 오브젝트와 환경에 의존한다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

### 테스트 대상 오브젝트 고립시키기
- 테스트의 대상이 환경이나 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다. (테스트를 위한 대역 사용, 테스트 스텁 또는 목 오브젝트)

#### 테스트를 위한 UserServiceImpl 고립
- UserDao: 정상적인 수행 + 부가적인 검증 기능까지 가진 목 오브젝트 생성, 그 이유는 고립된 환경에서 동작하는 upgradeLevels()의 테스트 결과를 검증할 방법이 필요하기 때문
- getAll(): 레벨 업그레이드 후보가 될 사용자의 목록을 받아온다. DB에 읽어온 것처럼 미리 준비된 사용자 목록을 제공해줘야 한다. (스텁)
- update(): upgradeLevels()의 핵심 로직인 전체 사용자 중에서 업그레이드 대상자는 레벨을 변경해준다에서 변경에 해당하는 부분을 검증할 수 있는 중요한 기능이다. (목 오브젝트)
- 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없을 뿐만 아니라 테스트 수행 성능도 크게 향상된다.
- 고립된 테스트를 만들려면 목 오브젝트 작성과 같은 약간의 수고가 더 필요할지 모르겠지만 그 보상은 충분히 기대할 만하다.

### 단위 테스트와 통합 테스트
- 단위 테스트의 단위는 정하기 나름이다. 사용자 관리 기능 전체를 하나의 단위로 볼 수도 있고 하나의 클래스나 하나의 메서드를 단위로 볼 수도 있다. 
- 토비의 스프링에서 정의한 단위 테스트는 의존 오브젝트나 외부 리소스를 사용하지 않고 고립시켜서 하는 테스트다.
- 통합 테스트는 다른 오브젝트나 외부 리소스가 참여하는 테스트
### 단위 테스트와 통합 테스트 중에서 어떤 방법을 쓸지에 대한 가이드 라인
- 항상 단위 테스트를 먼저 고려한다
- 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하여 테스트를 만든다
- 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다
- 단위 테스트로 만들기가 어려운 코드도 있다. 대포적인 게 DAO다. DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고 DB에 직접 확인을 하는 등의 부가적인 작업이 필요하다.
- 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다. 다만 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.
- 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다. 이때도 통합 테스트에 참여하는 코드 중에서 가능한 한 많은 부분을 미리 단위 테스트로 검증해두는게 유리하다.
- 스프링의 설정 자체도 테스트 대상이고 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야 할 경우도 종종 있다. 이럴 땐 스프링 테스트 컨텍스트 프레임워크를 이용해 통합 테스트를 작성한다.

코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다. 테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.
스프링이 지지하고 권장하는 깔끔하고 유연한 코드를 만들다보면 테스트도 그만큼 만들기 쉬워지고 테스트는 다시 코드의 품질을 높여주고 리팩토링과 개선에 대한 용기를 주기도 할 것이다.
  
## 6.3 다이내믹 프록시와 팩토리 빈
- 트랜잭션 경계설정 코드를 비즈니스 로직 코드에서 분리해낼 때 적용했던 기법을 다시 검토해보자
- 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야 한다.
- 그러기 위해서는 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 한다.
- 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 프록시라고 부른다. 그리고 프록시를 통해 최종족으로 요청을 위임받아 처리하는 실제 오브젝트를 타킷 또는 실체라고 부른다.
- 프록시는 사용 목적에 따라 두가지로 구분할 수 있다. 첫째는 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서다. 두 번째는 타깃에 부가적인 기능을 부여해주기 위해서다.

### 데코레이터 패턴
- 데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.
- 이를 위해 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있다.
- 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃으로 위임하는지 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.

### 프록시 패턴
- 일반적으로 사용하는 프록시라는 용어와 디자인 패턴에서 말하는 프록시 패턴은 구분할 필요가 있다. 전자는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭한다면 후자는 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.
- 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
- Collections의 unmodifiableCollection()을 통해 만들어지는 오브젝트가 전형적인 접근권한 제어용 프록시
- 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다.

### 다이내믹 프록시
- 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.
```java
public interface InvocationHandler {
    Object invoke(Object proxy, Method method, Object[] args)
}

```

```java 
Hello proxiedHello = (Hello) Proxy.newProxyInstance(
    getClass().getClassLoader(),
    new Class[] (Hello.class),
    new UppercaseHandler(new HelloTarget())
    );

```
- 다이내믹 프록시로부터 요청을 전달받으려면 InvocationHandler를 구현해야 한다. 다이내믹 프록시가 클라이언트로부터 받는 모든 요청은 invoke() 메소드로 전달된다. 다이내믹 프록시를 통해 요청이 전달되면 리플렉션 API를 이용해 타깃 오브젝트의 메소드를 호출한다.

### 다이내믹 프록시를 위한 팩토리 빈
- 스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러 가지 방법을 제공한다. 대표적으로 팩토리 빈을 이용하여 빈을 생성하는 것이다.
- 팩토리 빈이란 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈을 말한다.
- 팩토리 빈을 만드는 방법에는 여러 가지가 있는데 가장 간단한 방법은 FactoryBean 인터페이스를 구현하는 것이다.
- FactoryBean 인터페이스를 구현한 클래스를 빈으로 등록하면 팩토리 빈으로 동작한다.
- 참고로 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 오브젝트를 만들어준다. 리플렉션은 private으로 선언된 접근 규약을 위반할 수 있는 강력한 기능이 있기 때문이다.
- Proxy의 newProxyInstance() 메소드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다. 대신 팩토리 빈을 사용하면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어줄 수 있다.
#### 한계점
- 새로운 부가기능을 추가할 때마다 프록시와 프록시 팩토리 빈을 추가해줘야 한다.

## 6.4 스프링의 프록시 팩토리 빈
### ProxyFactoryBean
- 스프링의 ProxyFactoryBean은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다. ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.
- 여러 프록시가 공유해서 사용할 수 있다.
- MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받는다. 그 차이 덕분에 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다.
```java
class UppercaseAdvice implements MethodInterceptor {
    public Object invoke(MethodInvocation invocation) throws Throwable {
        String ret = (String)invocation.proceed();
	return ret.toUpperCase();
    }
}
```
- 다이내믹 프록시와 달리 ProxyFactoryBean 방식은 두 가지 확장 기능인 부가기능(Advice)와 메소드 선정 알고리즘(Pointcut)을 활용하는 유연한 구조를 제공한다.
- 어드바이스와 포인트컷은 모두 프록시에 DI로 주입돼서 사용된다.
- 두 가지 모두 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 스프링의 싱글톤 빈으로 등록이 가능하다.

#### proxyFactoryBean 동작원리
1. 프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할 메소드인지 확인해달라고 요청한다
2. 프록시는 포인트컷으로부터 부가기능을 적용할 대상 메소드인지 확인받으면 MethodInteceptor 타입의 어드바이스를 호출한다.


```java
@Test
public void pointcutAdvisor(){
    ProxyFactoryBean pfBean = new ProxyFactoryBean();
    pfBean.setTarget(new HelloTarget());

    NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();
    pointcut.setMappedName("sayH*");

    pfBean.addAdvisor(new DefaultPointcutAdvisor(pointcut, new UppercaseAdvice()));

    Hello proxiedHello = (Hello) pfBean.getObject();

    assertThat(proxiedHello.sayHello("Toby"), is("HELLO TOBY"));
    assertThat(proxiedHello.sayHi("Toby"), is("HI TOBY"));
    assertThat(proxiedHello.sayThankYou("Toby"), is("Thank You Toby"));
}

```


- MethodInterceptor는 타깃에 직접 의존하지 않도록 일종의 템플릿 구조로 설계되어 있다. (템플릭/콜백 구조)
- 포인트컷을 함께 등록할 때는 어드바이스와 포인트컷을 Advisor 타입으로 묶어서 addAdvisor() 메소드를 호출해야한다. 왜냐하면 ProxyFactoryBean에는 여러 개의 어드바이스와 포인트컷이 추가될 수 있기 때문이다. 포인트컷과 어드바이스를 따로 등록하면 어떤 어드바이스에 대해 어떤 포인트컷을 적용할지 애매해지기 때문이다.
- 토비의 스프링에서는 어드바이스, 포인트컷, 어드바이스, ProxyFactoryBean을 스프링 빈 설정하여 다이내믹 프록시 코드를 개선한다.
- 이렇게 설정된 스프링 빈은 다양한 서비스 클래스 등 재사용이 가능하다. (ProxyFactoryBean은 타깃의 정보를 하나만 담을수있기에 여러개의 ProxyFactoryBean을 등록하여 사용해야 한다.)
  
## 6.5 스프링 AOP
- 지금까지 해왔던 작업의 목표는 비즈니스 로직에 반복적으로 등장해야만 했던 트랜잭션 코드를 깔끔하고 효과적으로 분리해내는 것이다.

### 빈 후처리기를 이용한 자동 프록시 생성기 DefaultAdvisorAutoProxyCreator
- 스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 확장 포인트를 제공해준다.
- 그 중에서 관심을 가질 만한 확장 포인트는 바로 BeanPostProcessor 인터페이스를 구현해서 만드는 빈 후처리기다.
- 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다. 이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고 프록시를 빈으로 대신 등록할 수도 있다. 이것이 자동 프록시 생성 빈 후처리기다.

### 빈 후처리기를 이용한 자동 프록시 생성 방법
1. DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
2. 프록시 적용 대상이면 그때는 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고 만들어진 프록시에 어드바이저를 연결해준다.
3. 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해 준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에 돌려준다.
4. 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.

### 확장된 포인트컷(Pointcut 인터페이스)
```java
public interface Pointcut {
    ClassFilter getClassFilter(); // 프록시를 적용할 클래스인지 확인해준다.
    MethodMatcher getMethodMatcher(); // 어드바이스를 적용할 메서드인지 확인해준다.
}
```
- 포인트컷이 클래스 필터까지 동작해서 클래스를 걸러버리면 아무리 프록시를 적용했다고 해도 부가기능은 전혀 제공되지 않는다는 점에 주의해야 한다.

### DefaultAdvisorAutoProxyCreator 적용
- ProxyFactoryBean 제거와 서비스 빈의 원상복구

### 자동 프록시 생성기를 사용하는 테스트
- 자동 프록시 생성기는 스프링 컨테이너에 종속적인 기법을 사용했기 때문에 예외상황을 위한 ㅌ
