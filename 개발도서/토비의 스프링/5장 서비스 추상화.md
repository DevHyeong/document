# 5장 서비스 추상화
- 5장에서는 지금까지 만든 DAO에 트랜잭션을 적용해보면서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 살펴볼 것이다.

## 사용자 레벨 관리 기능 추가
- 요구사항
  - 사용자의 레벨은 BASIC, SILVER, GOLD 세가지 중 하나다.
  - 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
  - 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.
  - SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
  - 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

### 코드 개선(upgradleLevels 함수)
- 아래와 같은 질문을 할 수 있다.
  - 코드에 중복된 부분은 없는가?
  - 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
  - 코드가 자신이 있어야 할 자리에 있는가?
  - 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?
- 개선된 코드
  - 각 오브젝트와 메소드가 각각 자기 몫의 책임을 맡아 일하는 구조로 만들어졌음을 알 수 있다.
  - UserService, User, Level이 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조다.
  - 각자 자기 책임에 충실한 작업만 하고 있으니 코드를 이해하기도 쉽다.
  - 객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다.
  - 오브젝트에게 데이터를 요구하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이기도 하다.
  - 항상 코드를 더 깔끔하고 유연하면서 변화에 대응하기 쉽고 테스트하기 좋게 만들려고 노력해야 함을 기억하자

## 트랜잭션 서비스 추상화
- 정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크 문제 등 장애가 발생한다면 모두 초기 상태로 롤백하는 기능 추가

### 테스트용 UserService 대역
- 작업 중간 예외를 강제로 만들기 위한 테스트 클래스

### 트랜잭션 경계 설정
- 트랜잭션 경계: 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치
- JdbcTemplate는 템플릿 메소드가 호출될 때마다 트랜잭션이 새로 만들어지고 메소드를 빠져나오기 전에 종료된다.
- JdbcTemplate의 메소드를 사용하는 UserDao는 각 메소드마다 하나씩의 독립적인 트랜잭션으로 실행될 수 밖에 없다.
- 일련의 작업이 하나의 트랜잭션으로 묶이려면 그 작업이 진행되는 동안 DB 커넥션도 하나만 사용돼야 한다.
- UserService와 UserDao를 그대로 둔 채로 트랜잭션을 적용하려면 결국 트랜잭션의 경계설정 작업을 UserService 쪽으로 가져와야 한다.


### 트랜잭션 동기화
- 트랜잭션 동기화란 UserService에서 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고 이후에 호출되는 DAO의 메소드에서는 저장된 Connection을 가져다가 사용하게 하는 것이다. 정확히는 DAO가 사용하는 JdbcTemplate이 트랜잭션 동기화 방식을 이용하도록 하는 것이다.
- 그리고 트랜잭션이 모두 종료되면 그때는 동기화를 마치면 된다.
- 트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌이 날 염려는 없다.
- 스프링이 제공하는 트랜잭션 동기화 관리 클래스는 TransactionSynchronizationManager다.
