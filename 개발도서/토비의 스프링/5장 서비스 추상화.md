# 5장 서비스 추상화
- 5장에서는 지금까지 만든 DAO에 트랜잭션을 적용해보면서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 살펴볼 것이다.

## 사용자 레벨 관리 기능 추가
- 요구사항
  - 사용자의 레벨은 BASIC, SILVER, GOLD 세가지 중 하나다.
  - 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
  - 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.
  - SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
  - 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

### 코드 개선(upgradleLevels 함수)
- 아래와 같은 질문을 할 수 있다.
  - 코드에 중복된 부분은 없는가?
  - 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
  - 코드가 자신이 있어야 할 자리에 있는가?
  - 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?
- 개선된 코드
  - 각 오브젝트와 메소드가 각각 자기 몫의 책임을 맡아 일하는 구조로 만들어졌음을 알 수 있다.
  - UserService, User, Level이 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조다.
  - 각자 자기 책임에 충실한 작업만 하고 있으니 코드를 이해하기도 쉽다.
  - 객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다.
  - 오브젝트에게 데이터를 요구하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이기도 하다.
  - 항상 코드를 더 깔끔하고 유연하면서 변화에 대응하기 쉽고 테스트하기 좋게 만들려고 노력해야 함을 기억하자

## 트랜잭션 서비스 추상화
- 정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크 문제 등 장애가 발생한다면 모두 초기 상태로 롤백하는 기능 추가

### 테스트용 UserService 대역
- 작업 중간 예외를 강제로 만들기 위한 테스트 클래스

### 트랜잭션 경계 설정
- 트랜잭션 경계: 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치
- JdbcTemplate는 템플릿 메소드가 호출될 때마다 트랜잭션이 새로 만들어지고 메소드를 빠져나오기 전에 종료된다.
- JdbcTemplate의 메소드를 사용하는 UserDao는 각 메소드마다 하나씩의 독립적인 트랜잭션으로 실행될 수 밖에 없다.
- 일련의 작업이 하나의 트랜잭션으로 묶이려면 그 작업이 진행되는 동안 DB 커넥션도 하나만 사용돼야 한다.
- UserService와 UserDao를 그대로 둔 채로 트랜잭션을 적용하려면 결국 트랜잭션의 경계설정 작업을 UserService 쪽으로 가져와야 한다.


### 트랜잭션 동기화
- 트랜잭션 동기화란 UserService에서 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고 이후에 호출되는 DAO의 메소드에서는 저장된 Connection을 가져다가 사용하게 하는 것이다. 정확히는 DAO가 사용하는 JdbcTemplate이 트랜잭션 동기화 방식을 이용하도록 하는 것이다.
- 그리고 트랜잭션이 모두 종료되면 그때는 동기화를 마치면 된다.
- 트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌이 날 염려는 없다.
- 스프링이 제공하는 트랜잭션 동기화 관리 클래스는 TransactionSynchronizationManager다.

### 트랜잭션 서비스 추상화
- 문제 상황
  - 만약 여러 개의 DB를 사용하길 원하거나 JDBC가 아닌 하이버네이트를 사용하길 원한다면 트랜잭션 동기화를 어떻게 설정해야할까?
  - 해결책은 JTA를 사용하거나 Connection 기반이 아닌 Session 기반인 하이버네이트는 독자적인 트랜잭션 경계설정 코드로 바꿀수밖에 없다.
  - JDBC에 종속적인 Connection을 이용한 트랜잭션 코드가 등장하면서 요구사항에 대응하기가 까다로워졌다.
- 해결책
  - UserService의 코드가 특정 트랜잭션 방법에 의존적이지 않고 독립적일 수 있게 만들려면 어떻게 해야 할까?
  - 추상화란 하위 시스템의 공통점을 뽑아내서 분리시키는 것을 말한다.
  - JDBC, JTA, 하이버네이트, JPA 등 트랜잭션 개념을 갖고 있으니 모두 그 트랜잭션 경계설정 방법에서 공통점이 있을 것이다.
  - 이 공통적인 특징을 모아서 추상화된 트랜잭션 관리 계층을 만들 수 있다.
  - 그리고 애플리케이션 코드에서는 트랜잭션 추상 계층이 제공하는 API를 이용해 트랜잭션을 이용하게 만들어준다면 특정 기술에 종속되지 않는 트랜잭션 경계설정 코드를 만들 수 있을 것이다.
#### 스프링의 트랜잭션 서비스 추상화
- 스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다.
- 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스는 PlatformTransactionManager다.
- 스프링의 트랜잭션 추상화 기술은 앞에서 적용해봤던 트랜잭션 동기화를 사용한다.
- PlatformTransactionManager로 시작한 트랜잭션은 트랜잭션 동기화 저장소에 저장된다.
- DataSourceTransactionManager, JTATransactionManager, HibernateTransactionManager, JPATransactionManager
- 어떤 클래스든 스프링 빈으로 등록할 때 먼저 검토해야 할 것은 싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은가 하는 점이다.

## 서비스 추상화와 단일 책임 원칙
- 스프링의 트랜잭션 서비스 추상화 기법을 이용해 다양한 트랜잭션 기술을 일관된 방식으로 제어할 수 있게 됐다.
- 이렇게 기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 유연한 코드를 만들 수 있다.
- 트랜잭션의 추상화는 애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 트랜잭션 기술이라는 아에 다른 계층의 특성을 갖는 코드를 분리한 것이다.
- UserDao와 UserService는 인터페이스와 DI를 통해 연결됨으로써 결합도가 낮아졌다.
- 결합도가 낮다는 서로 독립적으로 확장될 수 있다는 뜻이다.
- 애플리케이션 계층의 코드가 특정 기술에 종속돼서 기술이 바뀔 때마다 코드의 수정이 필요하다면 어떨지 상상해보자.
- 그래서 적절하게 책임과 관심이 다른 코드를 분리하고 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고 애플리케이션 로직과 기술/환경을 분리하는 등의 작업은 갈수록 복잡해지는 엔터프라이즈 애플리케이션에는 반드시 필요하다.
- 이를 위한 핵심적인 도구가 바로 스프링이 제공하는 DI다. DI가 없었더라면 로우레벨 기술의 변화가 있을 때마다 비즈니스 로직을 담은 코드의 수정이 발생한다.
- DI를 통해 PlatformTransactionManager의 생성과 의존관계 설정을 스프링에 맡긴 덕에 완벽하게 트랜잭션 기술에서 자유로운 UserService를 가질 수 있게 된 것이다.

## 메일 서비스 추상화
- 
