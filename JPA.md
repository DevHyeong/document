# JPA 정리
참고 : 자바 ORM 표준 JPA 프로그래밍 김영한 지음

## JPA란?


## JPA를 사용해야 하는 이유
- 생산성
  - 반복적인 CRUD용 SQL을 개발자가 직접 작성하지 않아도 된다.

- 유지보수
  - JPA를 사용하지 않으면 엔테티(객체)에 필드를 하나만 추가해도 관련된 CRUD 쿼리를 모두 변경해야 한다.

- 패러다임의 불일치 해결
  - 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다. 반면 테이블은 외래키를 사용해서 다른 테이블과의 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다. 이렇듯 JPA는 객체와 관계형 데이터베이스의 서로 다른 패러다임을 손쉽게 해결해준다. 

- 성능
  
  
  
## 영속성 관리
### 엔티티 매니저 팩토리(EntityManagerFactory)
- 설정 정보를 읽어서 JPA를 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서는 데이터베이스 커넥션 풀도 생성하므로 엔티티 매니저 팩토리를 생성하는 비용은 아주 크다. 
- 엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다. 

### 엔티티 매니저(EntityManager)
- 엔티티 매니저 팩토리를 통해 엔티티 매니저가 생성된다.
- 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 CRUD를 할 수 있다.
- 엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. (트랜잭션을 시작할 때 커넥션을 획득한다.)
- 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간에 공유하거나 재사용하면 안된다.

### 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

### 엔티티의 생명주기
- 비영속
  - 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다.
- 영속
  - 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장.
  - 영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 의미
  - 관련 메서드: persist, find
- 준영속
  - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
  - 관련 메서드 : detach, close, clear 
- 삭제
  - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.
  - 관련 메서드 : remove 


### 영속성 컨텍스트의 특징
#### 영속성 컨텍스트와 식별자값
- 엔티티를 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)으로 구분한다. 따라서 영속 상태는 식별자 값이 반드시 있어야 한다.

#### 영속성 컨텍스트와 데이터베이스 저장
- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한다 (flush)

#### 1차 캐시
- 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다.
- 영속성 컨텍스트 내부에 Map이 하나 있는데 키는 @Id로 매핑한 식별자고 값은 엔티티 인스턴스다.


#### 동일성 보장
- 우선 동일성과 동등성에 대해 알아보자
  - 동일성(identity) : 실제 인스턴스가 같다. ( == )
  - 동등성(equality) : 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다.


#### 트랜잭션을 지원하는 쓰기 지원

#### 변경 감지


#### 지연로딩


## 고급 매핑



#### @IdClass
- 복합키를 지원해주는 어노테이션으로 다음의 조건을 만족해야한다.
  - 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다.
  - Serializable 인터페이스를 구현해야 한다.
  - equals, hashCode를 구현해야 한다. 
    (이유:영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리한다. 식별자를 비교할때 equals와 hashCode를 사용하기 때문에 식별자 객체의 동등성(eqals)이 지켜지지 않으면 예상과 다른 엔티티가 조회되거나 엔티티를 찾을 수 없는 등 영속성 컨텍스트가 엔티티를 관리하는데 심각한 문제가 발생하기 때문)
  - 기본 생성자가 있어야 한다.
  - 식별자 클래스는 public이어야 한다.
  
#### @EmbeddedId


## 즉시 로딩 / 지연 로딩 

### 즉시 로딩
- 엔티티를 조회할 때 연관된 엔티티도 함께 조회된다.(JPA의 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인쿼리를 사용한다.)
- ex) @ManyToOne(fetch = FetchType.LAZY)
- JPA는 기본적으로 외부조인을 사용한다. 내부조인시 데이터가 조회되지 않을 수 있기 떄문
  - 외부조인보다 내부조인이 서능과 최적화에서 유리하다.
  - 내부 조인을 사용할 수 있는 방법은? 외래키에 not null 제약조건을 설정한다. (@JoinColumn에 nullable = false를 설정)
- nullable 설정에 따라 조인전략을 변경할 수 있다
  - @JoinColumn(nullable = true) : NULL 허용(기본값), 외부 조인 사용
  - @JoinColumn(nullable = false), @ManyToOne(optional = false) : NULL 허용x, 내부 조인 사용
- JPA는 선택적 관계면 외부 조인, 필수 관계면 내부 조인

### 지연 로딩
- 연관된 엔티티를 실제 사용할 때 조회한다. (프록시 객체 사용), 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
- ex) @ManyToOne(fetch = FetchType.LAZY)
```
  Member member = em.find(Memeber.class, "member1"); // member만 조회되고 team은 조회하지 않는다.
  Team team = member.getTeam(); // 회원의 team 멤버변수에 프록시 객체를 넣는다.
  team.getName(); // 이처럼 실제 데이터가 필요한 순간 데이터베이스를 조회해서 프록시 객체를 초기화한다. select * from team where team_id = 'team1' 실행 
```
- 조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다. 따라서 프록시가 아닌 실제 객체를 사용한다.
- 컬렉션이 아닌 경우는 프록시 객체를 사용해서 지연 로딩을 수행하지만 엔티티에 컬렉션이 있을 경우 컬랙션 래퍼가 지연 로딩을 처리해준다.
- 예시
```
@oneToMany(mapperBy = "member", fetch = FetchType.LAZY)
private List<Order> orders;

```
- 참고로 member.getOrders() 를 호출해도 컬렉션은 초기화되지 않는다. member.getOrders().get(0)처럼 컬렉션에서 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화한다.


### JPA 기본 페치 전략
- @ManyToOne, @OneToOne : 즉시 로딩
- @OneToMany, @ManyToMany : 지연 로딩
- JPA의 기본 페치 전략은 연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용한다. 컬렉션을 로딩하는 것은 비용이 많이 들고, 잘못하면 너무 많은 데이터를 로딩할 수 있기 때문이다.
- 추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다. 그리고 애플리케이션 개발이 어느정도 완료단계에 왔을 때 실제 사용하는 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하면 된다.

### 컬렉션에 즉시 로딩 사용시 주의점
- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다. 컬렉션과 조인한다는 것은 데이터베이스 테이블로 보면 일대다 조인이다. 문제는 서로 다른 컬렉션을 2개 이상 조인할 때 발생한다. A테이블을 N, M 두 테이블과 일대다 조인하면 SQL 실행결과가 N x M이 되기 때문이다. 
- 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다. (데이터가 조회되지 않는 문제가 발생)




