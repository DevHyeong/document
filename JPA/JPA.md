# JPA 정리
참고 : 자바 ORM 표준 JPA 프로그래밍 김영한 지음

## JPA란?


## JPA를 사용해야 하는 이유
- 생산성
  - 반복적인 CRUD용 SQL을 개발자가 직접 작성하지 않아도 된다.

- 유지보수
  - JPA를 사용하지 않으면 엔테티(객체)에 필드를 하나만 추가해도 관련된 CRUD 쿼리를 모두 변경해야 한다.

- 패러다임의 불일치 해결
  - 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다. 반면 테이블은 외래키를 사용해서 다른 테이블과의 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다. 이렇듯 JPA는 객체와 관계형 데이터베이스의 서로 다른 패러다임을 손쉽게 해결해준다. 

- 성능
  
  
  
## 영속성 관리
### 엔티티 매니저 팩토리(EntityManagerFactory)
- 설정 정보를 읽어서 JPA를 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서는 데이터베이스 커넥션 풀도 생성하므로 엔티티 매니저 팩토리를 생성하는 비용은 아주 크다. 
- 엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다. 

### 엔티티 매니저(EntityManager)
- 엔티티 매니저 팩토리를 통해 엔티티 매니저가 생성된다.
- 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 CRUD를 할 수 있다.
- 엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. (트랜잭션을 시작할 때 커넥션을 획득한다.)
- 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간에 공유하거나 재사용하면 안된다.

### 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

### 엔티티의 생명주기
- 비영속
  - 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다.
- 영속
  - 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장.
  - 영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 의미
  - 관련 메서드: persist, find
- 준영속
  - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
  - 관련 메서드 : detach, close, clear 
- 삭제
  - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.
  - 관련 메서드 : remove 


### 영속성 컨텍스트의 특징
#### 영속성 컨텍스트와 식별자값
- 엔티티를 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)으로 구분한다. 따라서 영속 상태는 식별자 값이 반드시 있어야 한다.

#### 영속성 컨텍스트와 데이터베이스 저장
- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한다 (flush)

#### 1차 캐시
- 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다.
- 영속성 컨텍스트 내부에 Map이 하나 있는데 키는 @Id로 매핑한 식별자고 값은 엔티티 인스턴스다.


#### 동일성 보장
- 우선 동일성과 동등성에 대해 알아보자
  - 동일성(identity) : 실제 인스턴스가 같다. ( == )
  - 동등성(equality) : 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다.


#### 트랜잭션을 지원하는 쓰기 지원

#### 변경 감지


#### 지연로딩


## 고급 매핑



#### @IdClass
- 복합키를 지원해주는 어노테이션으로 다음의 조건을 만족해야한다.
  - 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다.
  - Serializable 인터페이스를 구현해야 한다.
  - equals, hashCode를 구현해야 한다. 
    (이유:영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리한다. 식별자를 비교할때 equals와 hashCode를 사용하기 때문에 식별자 객체의 동등성(eqals)이 지켜지지 않으면 예상과 다른 엔티티가 조회되거나 엔티티를 찾을 수 없는 등 영속성 컨텍스트가 엔티티를 관리하는데 심각한 문제가 발생하기 때문)
  - 기본 생성자가 있어야 한다.
  - 식별자 클래스는 public이어야 한다.
  
#### @EmbeddedId


